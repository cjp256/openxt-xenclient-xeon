diff --git a/part1/stages/Check-GPU b/part1/stages/Check-GPU
index 60470d9..f778df8 100755
--- a/part1/stages/Check-GPU
+++ b/part1/stages/Check-GPU
@@ -30,7 +30,7 @@ check_gfx()
             if grep -q '3....$' $i/class; then
                 vendor=$(cat $i/vendor)
                 case $vendor in
-                    "0x8086"|"0x1002") return 0;;
+                    "0x8086"|"0x1002"|"0x10de") return 0;;
                 esac
             fi
         fi
diff --git a/part2/stages/Functions/cpuinfo b/part2/stages/Functions/cpuinfo
new file mode 100644
index 0000000..b3a31e9
--- /dev/null
+++ b/part2/stages/Functions/cpuinfo
@@ -0,0 +1,63 @@
+#!/usr/bin/bash
+#
+# Copyright (C) 2015 Assured Information Security, Inc.
+# Author: Kyle J. Temkin <temkink@ainfosec.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+#
+# Prints the number of CPU cores,.
+#
+get_physical_cpu_cores()
+{
+    xenops physinfo | awk '/nr_cpus/ {print $3}'
+}
+
+#
+# Determines the number of cores per socket.
+#
+get_physical_cores_per_socket()
+{
+    xenops physinfo | awk '/cores_per_socket/ {print $3}'
+}
+
+#
+# Determines the number of cores per socket.
+#
+get_physical_threads_per_core()
+{
+    xenops physinfo | awk '/threads_per_core/ {print $3}'
+}
+
+#
+# Determines the number of cores per socket.
+#
+get_physical_threads_per_socket()
+{
+    local CORES_PER_SOCKET=$(get_physical_cores_per_socket)
+    local THREADS_PER_CORE=$(get_physical_threads_per_core)
+
+    echo $(($CORES_PER_SOCKET * $THREADS_PER_CORE))
+}
+
+#
+# Returns true iff the system has multiple sockets.
+#
+is_multi_socket()
+{
+    ! [[ $(get_physical_cpu_cores) -eq $(get_physical_cores_per_socket) ]]
+    return
+}
diff --git a/part2/stages/Functions/file-paths b/part2/stages/Functions/file-paths
index 4be4dcb..a4e0cf3 100644
--- a/part2/stages/Functions/file-paths
+++ b/part2/stages/Functions/file-paths
@@ -56,6 +56,7 @@ MBR_CONF="${INSTALL_DATA}/mbr.conf"
 PRESERVED_DATA_CONF="${INSTALL_DATA}/preserved-data.conf"
 EXISTING_CONF="${INSTALL_DATA}/existing-install.conf"
 UIVM_GCONF_VHD_KEY="${INSTALL_DATA}/uivm-gconf,aes-xts-plain,256.key"
+PCIBACK_CONF="${INSTALL_DATA}/pciback.conf"
 
 #-----------------------------------------------------------
 # Filesystem paths
diff --git a/part2/stages/Functions/install-main b/part2/stages/Functions/install-main
index 3b29894..288acec 100644
--- a/part2/stages/Functions/install-main
+++ b/part2/stages/Functions/install-main
@@ -17,6 +17,9 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 #
 
+. ${SCRIPT_DIR}/Functions/install-pciback
+. ${SCRIPT_DIR}/Functions/cpuinfo
+
 mk_xc_lvm()
 {
     local PARTITION_DEV="$1"
@@ -424,11 +427,35 @@ mount_config()
 
 install_bootloader_from_dom0fs()
 {
+    local GRUB_CONFIG="${DOM0_MOUNT}/boot/system/grub/grub.cfg"
+
     do_cmd chroot ${DOM0_MOUNT} \
            /usr/share/xenclient/install-bootloader "${LANGUAGE}" >&2 || {
         echo "Error installing the bootloader">&2
         return 1
     }
+
+    #Update the bootloader so it handles any necessary PCI passthrough options.
+    while read line; do
+        set_device_owner_to_pciback_static $line || {
+          echo "Error reserving devices for PCI passthrough"
+          return 1
+        }
+    done < ${PCIBACK_CONF}
+
+    #Hack for NUMA systems: if we have a multi-socket system, bind DOM0 to its
+    #first socket (which typically drives the primary display's PCI bus). Xen will
+    #then adjust NUMA memory accordingly.
+    #
+    #This /should/ be replaced with proper toolstack support for setting Node affinity,
+    #but the technology to make Xen guests -- including dom0-- aware of NUMA
+    #(Virtual NUMA support) is still a WIP in upstream Xen, and there's no good way
+    #to detect which node the graphics device belongs to, currently.
+    #
+    if is_multi_socket; then
+      sed -i "/XEN_COMMON_CMD/ s/\"$/ dom0_max_vcpus=$(get_physical_threads_per_socket) dom0_vcpus_pin\"/" ${GRUB_CONFIG} > /dev/null
+    fi
+
     return 0
 }
 
diff --git a/part2/stages/Functions/install-pciback b/part2/stages/Functions/install-pciback
new file mode 100644
index 0000000..0192c65
--- /dev/null
+++ b/part2/stages/Functions/install-pciback
@@ -0,0 +1,78 @@
+#!/bin/ash
+#
+# Copyright (C) 2015 Assured Information Security, Inc.
+# Author: Kyle J. Temkin <temkink@ainfosec.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+#
+# Adjusts the installed boot configuration to select devices which
+# should be passed to the pciback driver by default.
+#
+# arguments: module_name, bdf_to_hide
+#
+set_device_owner_to_pciback()
+{
+    #Determine if the xen_pciback module is installed on the target.
+    #We'll use this to decide whether we should use the icky static configuration
+    #or the slightly prettier dynamic one.
+    find "${DOM0_MOUNT}/lib/modules" -name xen_pciback.ko | grep "xen_pciback\.ko" > /dev/null
+
+    if [ $? -eq 0 ]; then
+      set_device_owner_to_pciback_module $@
+    else
+      set_device_owner_to_pciback_static $@
+    fi
+
+}
+
+
+set_device_owner_to_pciback_module()
+{
+  local DEVICE_MODULE="$1"
+  local DEVICE_BDF="$2"
+
+  local CONFIG_FILE="${DOM0_MOUNT}/modprobe.d/pciback.conf"
+
+  #Ensure the configuration file exits prior to our searching it it.
+  if ! [ -a ${CONFIG_FILE} ] ; then
+    echo "#Automatically generated by the installer." > ${CONFIG_FILE}
+  fi
+
+  #Hook the target device's installation, so we can ensure that pciback is loaded first.
+  #This ensures that the target device is bound to pciback, and not to its original driver.
+  grep "install ${DEVICE_MODULE}" "${CONFIG_FILE}" > /dev/null  \
+    || echo "install ${DEVICE_MODULE} /sbin/modprobe xen-pciback ; /sbin/modprobe --first-time --ignore-install ${DEVICE_MODULE}" >> ${CONFIG_FILE}
+
+  #If the file does not already contain pci-back hide options, add a line for them.
+  grep "options xen-pciback hide=" "${CONFIG_FILE}" > /dev/null || echo "options xen-pciback hide=" >> ${CONFIG_FILE}
+
+  #Add our device BDF to the start of the pciback hide array.
+  sed -i "/options xen-pciback/ s/hide=/hide=(${DEVICE_BDF})/" "${CONFIG_FILE}" > /dev/null
+
+}
+
+set_device_owner_to_pciback_static()
+{
+  local DEVICE_BDF="$2"
+  local GRUB_CONFIG="${DOM0_MOUNT}/boot/system/grub/grub.cfg"
+
+  #If the pciback hide option isn't already present in the target's grub.cfg, add it.
+  grep "xen-pciback.hide" ${GRUB_CONFIG} > /dev/null || sed -i "/LINUX_COMMON_CMD/ s/\"$/ xen-pciback.hide=\"/" ${GRUB_CONFIG} > /dev/null
+
+  #... and add the relevant device to the linux command line.
+  sed -i "/LINUX_COMMON_CMD/ s/xen-pciback.hide=/xen-pciback.hide=(${DEVICE_BDF})/" ${GRUB_CONFIG} > /dev/null
+}
diff --git a/part2/stages/Select-primary-gpu b/part2/stages/Select-primary-gpu
new file mode 100755
index 0000000..fa46d4a
--- /dev/null
+++ b/part2/stages/Select-primary-gpu
@@ -0,0 +1,148 @@
+#!/bin/bash
+
+
+. ${SCRIPT_DIR}/functions
+. ${SCRIPT_DIR}/Functions/install-pciback
+
+#
+# Prints a human-friendly name for the given DRM-enabled graphics card.
+#
+get_card_name()
+{
+    local CARD="$1"
+    local BDF=$(get_card_bdf $CARD)
+
+    #Ask lspci for information about the given PCI device...
+    DATA=$(lspci -m -s $BDF)
+
+    #... and extract the Vendor and main device name.
+    echo $DATA | awk -F\" '{print $4, $6}'
+}
+
+#
+# Returns the BDF for the given DRM device.
+# TODO: Rewrite this so it doesn't depend on UDEV's uevent export?
+#
+get_card_bdf()
+{
+    local CARD="$1"
+    sed -n "/PCI_SLOT_NAME/ s/PCI_SLOT_NAME=//p" /sys/class/drm/$CARD/device/uevent
+}
+
+#
+# Returns the driver for the given DRM device.
+# TODO: Rewrite this so it doesn't depend on UDEV's uevent export?
+#
+get_card_driver()
+{
+    local CARD="$1"
+    sed -n "/DRIVER/ s/DRIVER=//p" /sys/class/drm/$CARD/device/uevent
+}
+
+#
+# Returns true iff the given DRM card is the display being used for installation.
+#
+is_current_display()
+{
+    local CARD="$1"
+    [ $(cat /sys/class/drm/$CARD/device/boot_vga) -eq 1 ]
+}
+
+#Get a list of all DRM-enabled graphics cards present on the machine.
+CARDS=$(ls /sys/class/drm/ | egrep "^card[0-9]+$" )
+
+#
+# Iterate over all graphics cards in current use, and build
+# a menu of displays the user can select between.
+#
+VALID_CARD_COUNT=0
+BDFS=""
+declare -A DRIVERS
+DEFAULT_BDF=""
+for CARD in $CARDS; do
+
+    BDF=$(get_card_bdf $CARD)
+    NAME=$(get_card_name $CARD)
+    DRIVER=$(get_card_driver $CARD)
+
+    #Compose a list of all known identifiers and drvers.
+    BDFS="${BDFS=}${BDFS:+ }${BDF}"
+    DRIVERS[$BDF]=$DRIVER
+
+    #Filter out known bad devices-- for example, any Radeons
+    #who don't play nicely with GBM. These will count as cards,
+    #but won't be usable as a primary device.
+    if [ ${DRIVER} = "radeon" ]; then
+      continue;
+    fi
+
+    #And increment the total "card count".
+    VALID_CARD_COUNT=$(( $VALID_CARD_COUNT + 1 ))
+
+    #And build the string that will be used to display the menu.
+    MENU_STRING="${MENU_STRING}\"${BDF}\" \"${NAME}\" "
+
+    #If this is the current display, use it as the default selection.
+    #TODO: Will this always be an i915, if they're present? If not, we
+    #should override this logic to always accept an i915. Buh, heuristics!
+    is_current_display $CARD && DEFAULT_BDF="${BDF}"
+
+done
+
+#If we don't have a default display, set it to the first available BDF.
+[ "x$DEFAULT_BDF" = "x" ] && DEFAULT_BDF=${BDFS[0]}
+
+#In some cases, there's only really one sane choice, and we should make it for the user:
+#   -If there's only one graphics card, it must be the primary display.
+#   -If we have an Intel integrated, it can /only/ be used for the multiplexed display,
+#    so it should be the primary. (We also get slightly better performance.)
+#   -If we're in an interactive install, use the sane default of the current display. 
+#    TODO: Get this from an answerfile, instead?
+if (! interactive) || [ $VALID_CARD_COUNT -eq 1 ] || [ ${DRIVERS[$DEFAULT_BDF]} = "i915" ]; then
+    PRIMARY_BDF="$DEFAULT_BDF"
+
+    #Corner case: if we got here via Previous, and this wasn't an interactive case,
+    #then the user never saw this screen-- and they want to be on the screen prior.
+    not_previous || exit ${Previous}
+
+#Otherwise, prompt the user to select a card.
+else
+
+    CARD_DESCRIPTION="Select the graphics card to be used as the primary display.\n\n\
+This card will be used to display the main ${PRODUCT_BRAND} multiplexed display. \
+Do not select a card that you would like to use as a pass-through card. If the display \
+being used for installation is compatible, it will be selected as the default option below."
+
+    #
+    #Prompt the user to select the card they want to use.
+    #
+    CAPTURE=$(mktemp -t)
+    echo ${MENU_STRING} | xargs dialog --ok-label Select --default-item "$DEFAULT_DISPLAY" --menu "$CARD_DESCRIPTION" 0 0 0 2>${CAPTURE}
+    RETURN=$?
+    PRIMARY_BDF=$(cat ${CAPTURE} 2>/dev/null)
+    rm -f ${CAPTURE}
+
+    #If the user cancels, move backwards through the installer.
+    [ ${RETURN} != 1 ]   || exit ${Previous}
+    [ ${RETURN} != 123 ] || exit ${Previous}
+    [ ${RETURN} != 124 ] || exit ${Previous}
+    [ ${RETURN} != 255 ] || exit ${Previous}
+
+fi
+
+#
+#Build what we're really after: a list of devices that should not be used by dom0
+#in the new install. These will be added to pciback on the kernel command line.
+#
+for BDF in $BDFS; do
+  #Skip the primary BDF; as this /will/ be passed to dom0.
+  [ $BDF = $PRIMARY_BDF ] && continue
+
+  #But set every other device as a PCI-passthrough device.
+  touch ${PCIBACK_CONF}
+  echo "${DRIVERS[$BDF]}" "$BDF" >> ${PCIBACK_CONF}
+
+done
+
+exit ${Continue}
+
diff --git a/part2/stages/install-main.graph b/part2/stages/install-main.graph
index bc871a7..68a6cd1 100644
--- a/part2/stages/install-main.graph
+++ b/part2/stages/install-main.graph
@@ -8,11 +8,14 @@ Find-existing-install,        Install:Select-hard-disk | Upgrade:Ready-to-upgrad
 Select-hard-disk,             Continue:Configure-partitions | Abort:Fail
 Configure-partitions,         Continue:Configure-MBR | Abort:Fail
 Configure-MBR,                Continue:Warn-disk-erasure | Abort:Fail
-Warn-disk-erasure,            Continue:Set-password | Abort:Fail
+Warn-disk-erasure,            Continue:Select-primary-gpu | Abort:Fail
+
+Select-primary-gpu,           Continue:Set-password | Abort:Fail
 
 Set-password,                 Continue:Enable-SSH | Abort:Fail
 Enable-SSH,                   Continue:TPM-Begin | Abort:Fail
 
+
 TPM-Begin,                    Continue:TPM-Check | Abort:TPM-RUSure
 TPM-Check,                    Continue:Configure-VHDs | TpmBadSrk:TPM-BadSrk | TpmDisabled:TPM-Disabled | TpmInactive:TPM-Inactive | TpmOwned:TPM-Owned | TxtFail:TXT-Fail | Abort:Unexpected-failure
 TPM-BadSrk,                   Continue:TPM-RUSure | Abort:Fail
@@ -40,6 +43,7 @@ Install-hook,                 Continue:Make-XC-partition | Abort:Fail
 Make-XC-partition,            Continue:Install-fresh | Abort:Fail
 Install-fresh,                Continue:Post-install-hook | Abort:Unexpected-failure
 
+
 Post-install-hook,            Continue:Succeed | Abort:Fail
 
 Succeed,                      Continue:End{Continue}
